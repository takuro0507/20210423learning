# 目次

1. Node.js の誕生と commonJS
2. パッケージ管理システム npm
3. ブラウザとモジュール（IIFE ,AMD,Bower)
4. バンドルツール(Browserify,webpack)
5. ES Modueles の策定
6. ES2015 と Babel

---

# 要点

- **ブラウザでモジュールを使うために**模索した結果、コードを事前に変換することが主流になった。コードを事前に変換するとモジュールを支える以外にもいろんな恩恵があるということ。

---

# Node.js の誕生と commonJS

## Node.js の誕生

##### 2009 年に誕生(CommonJS のモジュール API に準拠)　　　

## CommonJS 形式のモジュール

- JavaScript にはモジュールの使用が複数あり.
- その中の CommonJS 形式は Node.js で使用。

---

## モジュールの次はパッケージ管理をしたい

- パッケージとは**package.json**で記述されたファイルやディレクトリのこと。

---

## モジュールのおかげで機能の細分化ができるようになった

- 共有の需要が生まれた
- 共有したい機能の単位がパッケージ

---

## パッケージ管理システム

1. リポジトリの購読

- ローカル環境にインストールしたパッケージを更新できる。パッケージを検索できる。

2. パッケージのインストール・削除

- パッケージを指定してローカルにインストールできる。反対にローカルから削除することもできる。

3. 依存関係の解決

- パッケージに必要な別のパッケージを自動的にインストールや更新することができる。

4. 設定管理

- 設定を書くことで１・２・３を自動でおこなえる。毎回手動でパッケージを入れる必要がなくなり、チームで環境を簡単に揃えたりすることができる。

#### パッケージを手動で管理するのは非効率　 → 　 npm の誕生(Node.JS のパッケージ管理システム)

---

## EXPRESS のインストール

- これでサーバーサイド JS の準備は整った

---

## Node.js が普及

- etc:yahoo,LinkedIn,Paypal

---

## ここまではあくまでもサーバーサイドの話

---

---

# 歴史後編　その２

---

## ブラウザ側のモジュールのパターン　４つ

- IIFE(即時実行関数式)を利用している -それだけだと不十分

## AMD&RequireJS の誕生

## AMD とは

- ブラウザ環境での実行を考慮し依存関係の解決及び遅延ロードに対応した仕様。

## ブラウザ向けパッケージ管理システムが欲しい　 → 　 Bower が誕生

- 簡単に言うと npm と似た機能

## IIFE、AMD でモジュールが使え、Bower でパッケージ管理システムも使えるようになった。

- AMD の構文は CommonJS を比較して冗長。サーバー側の機能とは互換性なし。
- 依存関係が多いとメンテナンスが大変、パフォーマンス面でも問題あり。

- Bower はどのパッケージが依存しているかをユーザーが定義する必要あり。同一パージ内にある同じパッケージの異なるバージョンをサポートしていなかった。

# ここからブラウザ JavaScript が大幅に進化

---

# 歴史完結編

---

## いったんモジュールまとめ

- IIFE 欠点あり
- AMD 　欠点あり
- CommonJS
- (UMD)

## → 　考え方を変える

- CommonJS 形式で書かれたものを**事前にブラウザ向けに変換する。**
  書いたコードと動くコードが違う。

## 事前にブラウザ向けに変換

- Bundle
- Compile

## Bundle を使うと・・・

1. 開発時は CommonJS モジュールで開発。
2. モジュールの依存関係を解決して１ファイルに変換(これがバンドル)
3. 変換したコードをいつも通り script タグで読み込む

## Browserify の誕生

- CommonJS 形式で書かれたものをブラウザ向けにバンドルするツール
- 全ての依存関係を束ねてブラウザで require('modules')を使用可能にする
- Node.js と同様に require を使うコードが使用できる
- ブラウザでも require 構文を用いてモジュールを書くことができるようになった。
- Node.js のパッケージがブラウザ向けに移植された。
- 結果的に CommonJS 形式で書かれた npm を Browserify でブラウザ向けに変換できることで**ブラウザでも npm**が使われるようになった。
- Bower はだんだん使われなくなった

## webpack が２０１２年に誕生

- Browserify の上位互換バンドルツール
- 主に JavaScript 向けだが、HTML,CSS,画像などのフロントエンドのもの(アセット)も変換(バンドル)することができる。
- 特徴：バンドルする前は依存関係あり
- 特徴：バンドル後は依存関係がなくなる
- JS に限らずなんでもバンドルできる
- Code Splitting で最初のロード時間を短縮することができる

---

# EcmaScript について

---

## ES Modules 誕生

- ES2015 で JavaScript の言語仕様としてモジュールの仕組みが導入。
- CommonJS,AMD などのモジュール論争がなくなる
- まだほとんどのブラウザで ES Modules はサポートされていなかった。モジュールバンドラーが必要な流れは変わらない。
- ES modules でコードを書きたい要望が高まる

## webpack で ESModules 対応

- version2 でネイティブサポート
- import 構文で開発可能に

## ESModules のサポート状況

- webpack を通さなくても、IE 以外のモダンブラウザと Node.js の version12 以上では標準で使用可能。

---

# いったんまとめ(バンドル)

- モジュールバンドラーが流行る（特に webpack）
- モジュールバンドラーがあれば CJS や ESM でモジュールを使ってコードが書ける
- CJS 主流だった npm もクライアント開発で使える　＝　ブラウザでもパッケージ管理システムも使える

## → 　ブラウザでもモジュールとパッケージ管理システムが使えるようになった

---

## Compile を使うと・・・

1. 開発時はブラウザでは動かないが、開発に便利な機能を使ってコードが書ける
1. 書いたコードをブラウザで動くように変換する（これがコンパイル）
1. 変換したコードをいつも通り script タグで読み込む

## ES2015 はモジュール以外にも機能追加多数

- let,const,class,promise,アロー関数、分割代入、スプレッド構文、テンプレート文字列など追加
- しかし、すぐには使えなかった
- IE では使えなかった

## Babel(6to5)誕生

- ES2015 などで書かれたコードを従来の環境でも動くように古い JavaScript に変換するコンパイラ。
- webpack と一緒に使うことができた
- モジュール＋依存関係の解決＋ ES2015 の新機能が使えるようになった
- JavaScript が便利になっていった

## コンパイルの可能性拡大

- コンパイルが当たり前になることで ES2015 以外にも便利なパッケージが流行理だす。
- React(.jsx)
- Vue(.vue)
- TypeScript(.ts)
- これはそのままブラウザで読み込めない
- 事前にコンパイルすることで JavaScript にしてブラウザで読み込むことができる

---

# まとめ

- ブラウザでモジュールを使うために模索した結果、**コードを事前に変換すること**が主流になった。コードを事前に変換するとモジュールを使える以外にもメリットあり。
- 事前に変換というパラダイムシフトによって jQuery が使われなくなった。事前に変換することでモジュールも使えるし、ES2015 の新機能や TypeScript などが使える。

---

# 覚えるべきもの

- Node.js
- パッケージ管理システム
- npm(package.json)
- 事前に変換（Bundle,Compile)
- webpack
- Babel
- ES Modules
- ES2015 → ES2020 が最新
- React
- Vue
- TypeScript

---
